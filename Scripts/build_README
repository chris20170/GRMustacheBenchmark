#!/usr/bin/env ruby

def dichotomy(min,max,&block)
  vmin = block[min]
  vmax = block[max]
  loop do
    return min if (max - min) <= Float::EPSILON
    center = (min + max)/2.0
    vcenter = block[center]
    return center if vcenter.abs <= Float::EPSILON
    if vcenter*vmin > 0
      min = center
      vmin = vcenter
    else
      max = center
      vmax = vcenter
    end
  end
end

def inv_erf(x)
  dichotomy(0,6) { |y| Math.erf(y) - x }
end

# numbers_in_confidence_interval([gaussian distributed numbers of average 0 and standard deviation 1], Math.erf(1/Math.sqrt(2))) => numbers between -1 and 1
def numbers_in_confidence_interval(numbers, confidence_interval)
  average = numbers.inject(&:+) / numbers.count
  standard_deviation = Math.sqrt(numbers.map { |number| (number-average)*(number-average) }.inject(&:+) / numbers.count)
  threshold = inv_erf(confidence_interval) * Math.sqrt(2) * standard_deviation
  numbers.find_all { |number| (number-average).abs <= threshold }
end


ROOT=File.join(File.dirname(__FILE__), '..')
LABEL_FOR_TASK = {
  'combined' => 'Parsing+Rendering',
  'parse' => 'Parsing',
  'render' => 'Rendering',
}

tasks = []
versions = []
scenarios = []
sample_for_version_for_scenario_for_task = {}
min_sample = nil

Dir.glob(File.join(ROOT, 'Product', 'samples', '**', '*')).each do |path|
  next unless File.extname(path) == '.samples'
  
  version = File.basename(path).gsub(/\.samples$/, '')
  versions |= [version]
  
  task = File.basename(File.dirname(path))
  tasks |= [task]
  
  scenario = File.basename(File.dirname(File.dirname(path)))
  scenarios |= [scenario]
  
  samples = File.read(path).map { |sample_line| sample_line.strip.to_f }
  samples = numbers_in_confidence_interval(samples, 0.5)  # keep 50% of the population
  sample = samples.inject(&:+) / samples.count  # average
  
  min_sample = sample if min_sample.nil? || min_sample > sample
  
  sample_for_version_for_scenario_for_task[task] ||= {}
  sample_for_version_for_scenario_for_task[task][scenario] ||= {}
  sample_for_version_for_scenario_for_task[task][scenario][version] = sample
end

versions = versions.sort_by { |version| version.scan(/\d*/).delete_if(&:empty?).map { |n| '%03d' % (n.to_i) }.join.to_i }


puts <<-MARKDOWN
# GRMustache benchmarks

You can here compare the performance of all [GRMustache](https://github.com/groue/GRMustache) versions since v1.7.1 (the first shipped as a static library).

GRMustache has been tested against the scenarios stored in the [Scenarios](GRMustacheBenchmark/tree/master/Scenarios) directory.

- `medium`: a reasonable Mustache template, that comes straight from a real application.
- `short`: a very very short template.

For each version and scenario, we benchmark three different tasks: parsing, rendering, and combined parsing+rendering.

MARKDOWN

time_precision = 1
time_width = time_precision+6
sample_column_width = [scenarios.map(&:length).max, time_width].max + 2
version_column_width = versions.map(&:length).max + 2
sample_format = "%%%d.%de" % [time_width, time_precision]
line_format = ("\t%%-%ds" % version_column_width) + (("%%%ds" % sample_column_width) * scenarios.count)
tasks.each do |task|
  puts
  puts "## #{LABEL_FOR_TASK[task]} task"
  puts
  puts line_format % ([""]+scenarios)
  versions.reverse.each do |version|
    time_strings = scenarios.map do |scenario|
      sample = begin sample_for_version_for_scenario_for_task[task][scenario][version] / min_sample rescue nil end
      if sample
        sample_format % sample
      else
        "n/a"
      end
    end
    puts line_format % ([version] + time_strings)
  end
end

puts <<-MARKDOWN

-----

This README.md file has been generated with the `make` command.

MARKDOWN
